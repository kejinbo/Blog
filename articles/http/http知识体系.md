# http知识体系

## http 报文结构是怎样的？

对于TCP而言，在传输的时候分为两个部分：TCP头和数据部分。

而http类似，也是`header + body`的结构：

```html
起始行 + 头部 + 空行 + 实体
```

由于 http `请求报文` 和 `响应报文`是有一定区别，因此我们分开介绍。

### 起始行

对于请求报文来说，起始行类似下面：

```js
GET /home HTTP/1.1
// 方法 + 路径 + http版本
```

对于响应报文来说，起始行（也叫`状态行`）一般是：

```js
HTTP/1.1 200 OK
// http版本 + 状态码 + 原因
```

值得注意的是，在起始行中，每两个部分之间用**空格**隔开，最后一个部分后面应该接一个**换行**，严格遵循[ABNF](https://baike.baidu.com/item/%E6%89%A9%E5%85%85%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F/23121009?fr=aladdin)语法规范。

### 头部格式

下面是**请求头**和**响应头**在报文中的位置：

![请求头](https://user-gold-cdn.xitu.io/2020/3/22/170ffd6012e2fc88?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

![响应头](https://user-gold-cdn.xitu.io/2020/3/22/170ffd62af8538e4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

重点看看这些头部字段的格式：

- 字段名不区分大小写
- 字段名不允许出现空格，不可以出现下划线`_`
- 字段名后面必须紧跟着`:`

### 空行

空行是用来区分`头部`和`实体`的。

如果说在头部中间故意加一个空行会怎么样呢？  
答：那么空行后面的全部内容都会被当成实体。

### 实体

就是具体的数据，也就是`body`部分。请求报文对应`请求体`，响应报文对应`响应体`。

## 如何理解HTTP的请求方法

`http/1.1`规定了一下请求方法（注意，都是大写）：

- GET：通常用来获取资源
- HEAD：获取资源的元信息
- POST: 提交数据，即上传数据
- PUT：修改数据
- DELETE：删除资源（几乎用不到）
- CONNECT：建立连接隧道，用于代理服务器
- OPTIONS：列出可对资源实行的请求方法，用来跨域请求
- TRACE：追踪请求-响应的传输路径

### GET 和 POST 有什么区别

首先最直观的是语义上的区别。然后又有下面一些区别：

- **从缓存的角度**，GET请求会被浏览器主动缓存下来，留下历史记录，而POST默认不会。
- **从编码的角度**，GET只能进行URL编码，只能接收ASCLL字符，而POST没有限制。
- **从参数的角度**，GET一般放在URL中，因此不安全，POST放在请求体中，更适合传输敏感信息。
- **从幂等性的角度**，GET是[幂等](https://developer.mozilla.org/zh-CN/docs/Glossary/%E5%B9%82%E7%AD%89)的，而POST不是。(`幂等`表示执行相同的操作，结果也是相同的)。
- **从TCP的角度**，GET请求会把请求报文一次性发出去，而POST会分为两个TCP数据包，首先发header部分，如果服务器响应100(continue)，然后发body部分。(火狐浏览器除外，它的POST请求只发一个 TCP 包)。

## 如何理解 URI

**URI**，全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。

但是，他并不是我们常说的`网址`，网址指的是`URL`，实际上`URI`包含了`URN`和`URL`两个部分，由于`URL`过于普及，就默认将`URI`视为`URL`了

### URI的结构

![uri的结构图](https://user-gold-cdn.xitu.io/2020/3/22/170ffd677629b70d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- **scheme** 表示协议名，比如http，https，file等等。后面必须和`://`连在一起。
- **user:passwd** 表示登录主机是的用户信息，不过很不安全，不推荐使用，也不常用。
- **host:port** 表示主机名和端口
- **path** 表示请求路径，标记资源所在位置。
- **query** 表示查询参数，为`key=val`这种形式，多个键值对之间用`&`隔开。
- **fragment** 表示URI所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。

举个例子：

```js
https://www.baidu.com/s?wd=HTTP$rsv_spt=1

// 这个 uri 中，https 即 scheme 部分，www.baidu.com 为 host:post 部分 （注意, http 和 https 的默认端口分别是 80、443），/s 为 path 部分，而 wd=HTTP$rsv_spt=1 就是 query 部分。
```

### URI 编码

URI 只能使用 ASCII，ASCII之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。

因此，URI引入了编码机制，将所有非ASCII码字符和界定符转为十六进制字节值，然后在前面加个 `%`

如，空格被转义成了 `%20`，三元被转义成了 `%E4%B8%89%E5%85%83`。

## 如何理解 HTTP 状态码

[RFC](https://baike.baidu.com/item/RFC/1840)规定http的状态码为三位数，被分为五类：

- 1xx：表示目前是协议处理的中间状态，还需要后续操作。
- 2xx：表示成功状态。
- 3xx：重定向状态，资源为主发生变动，需要重新请求。
- 4xx：请求报文有误。
- 5xx：服务器端发生错误。

下面我们分析一下具体的状态码。

### 1xx

- **101** Switching Protocols。在http升级为 Websocket 的时候，如果服务器同意变更，就会发送状态码 101 。

### 2xx

- **200** OK 是见得最多的成功状态码。通常在响应体中放有数据。
- **204** No Content含义与200相同，但响应头后没有body数据。
- **206** Partial Content 顾名思义，表示部分内容，他的使用场景为 HTTP分块下载和断电续传，当然也会带上相应的响应头字段 Content-Range。

### 3xx

- **301** Moved Permanently 即永久重定向，对应着 302 found，即临时重定向。  
比如你的网站从HTTP升级到HTTPS了，以前的站点再也不用了，应当返回301，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。  
而如果只是暂时不可用，那么直接返回302即可，和301不同的是，浏览器并不会做缓存优化。

- **304** Not Modified 当协商缓存命中时会返回这个状态码。详见[浏览器缓存](http://47.98.159.95/my_blog/perform/001.html)

### 4xx

- **400** bad request 笼统地提示一下错误，并不知道哪里出错了。
- **401** forbidden 实际上不是报文错误，而是服务器禁止访问，原因有很多，比如法律禁止，信息敏感等。
- **404** not found 资源未找到，表示在服务器上没有找到对应的资源。
- **405** Method Not Allowed 请求方法不被服务器端允许。
- **406** Not Acceptable 资源无法满足客户端的条件。
- **408** Request Timeout 服务器等待了太长时间。
- **409** Conflict 多个请求发生了冲突。
- **413** Request Entity Too Large 请求体的数据过大。
- **414** Request-URI Too Long 请求行里的 URI 太大。
- **429** Too Many Request: 客户端发送的请求过多。
- **431** Request Header Fields Too Large请求头的字段内容太大。

### 5xx

- **500** Internal Server Error 仅仅告诉你服务器出错了，出了啥错咱也不知道。
- **501** Not Implemented 表示客户端请求的功能还不支持。
- **502** Bad Gateway 服务器自身是正常的，但访问的时候出错了，啥错误咱也不知道。
- **503** Service Unavailable 表示服务器当前很忙，暂时无法响应服务。

## 简要概括一下http的特性

### HTTP特点

- 灵活可扩展，主要体现在两个方面。一个是语义上的自由，只规定了基本格式，比如空格分割单词，换行分割字段，其他的各个部分都没有严格的语法限制。另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片，视频等任意数据。
- 可靠传输。HTTP基于 TCP/IP, 因此把这一特性继承了下来。
- 请求-应答。也就是一发一收，有来有回，当然这个请求放和应答放不单单指客户端和服务器之间，如果某台服务器作为代理来连接后台的服务端，那么这台服务器也会扮演请求发的角色。
- 无状态。这里的状态是指通信过程的上下文信息，而每次http请求都是独立的，无关的，默认不需要保留状态信息。

### HTTP缺点

#### 无状态

所谓的优点和缺点还是分场景来看的。对于HTTP而言，最具争议的地方在于它的无状态。

在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。

但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。

#### 明文传输

即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。

这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI陷阱就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。

#### 队头阻塞问题

当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。接下来会有一小节讨论这个问题。

## http 中如何处理表单数据的提交

在 http 中，有两种主要的表单提交的方式，体现在两种不同的 `Content-Type` 取值：

- application/x-www-form-urlencoded
- multipart/form-data

由于表单提交一般是`POST`请求，很少考虑`GET`，因此这里我们将默认提交的数据放在请求体中。

### application/x-www-form-urlencoded

对于 `application/x-www-form-urlencoded` 格式的表单内容，有以下特点：

- 其中的数据会被编码成以 & 分隔的键值对
- 字符以URL编码方式编码。

如：

```js
// 转换过程: {a: 1, b: 2} -> a=1&b=2 -> 如下(最终形式)
"a%3D1%26b%3D2"
```

### multipart/form-data

对于 `multipart/form-data` 而言：

- 请求头中的 `Content-Type` 字段会包含boundary，而boundary的值有浏览器默认指定。例：`Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe`
- 数据会分为多个部分，每两个部分之间通过分隔符分隔，每部分表述有http头部描述子包体，如`Content-Type`，在最后的分隔符会加上 --表示结束。

对应的请求体如下：

```js
Content-Disposition: form-data;name="data1";
Content-Type: text/plain
data1
----WebkitFormBoundaryRRJKeWfHPGrS4LKe
Content-Disposition: form-data;name="data2";
Content-Type: text/plain
data2
----WebkitFormBoundaryRRJKeWfHPGrS4LKe--
```

### 小结

`multipart/form-data`格式最大的特点在于，每个表单元素都是独立的资源表述。另外，你可能在写业务的过程中，并没有注意到其中有boundary的存在，如果你打开抓包工具，确实可以看到不同的表单元素被拆分开来了，之所以平时感觉不到，是因为浏览器和HTTP给你封装了这一系列操作。

而且，在实际的场景中，对于图片等文件的上传，基本采用`multipart/form-data`而不用 `application/x-www-form-urlencoded`，因为没有必要做URL编码，带来巨大耗时的同事也占用了更多空间。

## HTTP1.1如何解决HTTP的队头阻塞问题？

### 什么是HTTP队头阻塞？

前面的小节可以知道，HTTP传输是基于`请求-应答`的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的`http队头阻塞`。

### 并发连接

> 长连接：本质上是说的TCP连接。TCP连接是一个双向通道，它是可以保持一段时间不关闭的，因此TCP连接才有真正的长连接和短连接这一说

对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发2个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome中是6个。

### 域名分片

一个域名不是可以并发6个长连接吗？那我就多分几个域名。

比如：a.keke.com、b.keke.com

这样一个 `keke.com` 域名下可以分出非常多的二级域名，而他们都指向同样的一台服务器，能都并发的长连接更多了，事实上也更好地解决了队头阻塞的问题。

## cookie

### cookie 简介

前面说到了http是一个无状态的协议，每次http请求都是独立、无关的、默认不需要保留状态信息。但有时候需要保存一些状态，怎么办？

http为此引入了cookie。cookie本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式存储（在Chrome开发者面板的application这一栏可以看到）。向同一域名下发送请求，都会携带相同的cookie，服务器拿到cookie进行解析，便能拿到客户端的状态。而服务端可以通过响应头中的 `Set-Cookie`字段来对客户端写入cookie。

```js
// 请求头
cookie: a=xxx;b=xxx
// 响应头
set-cookie: a=xxx
set-cookie: b=xxx
```

### cookie 属性

#### 生存周期

cookie 的有效期可以通过**Expires** 和 **Max-Age**两个属性来设置。

- **Expires**即`过期时间`
- **Max-Age**用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算。

若cookie过期，则这个cookie会被删除，并不会发送给服务端。

#### 作用域

关于作用域也有两个属性：**Domain** 和 **path**，给 **Cookie**绑定了域名和路径，在发送请求之前，发现域名或者路径这两个属性不匹配，那么久不会带上cookie。值得注意的是，对于路径来说，`/`表示域名下的任何路径都允许使用cookie。

#### 安全相关

如果带上 `secure`，说明只能通过https传输cookie。

如果cookie字段带上`HttpOnly`，那么说明只能通过HTTP协议传输，不能通过js访问（即，通过js获取cookie时，带上`HttpOnly`的字段将被过滤掉），这也是预防xss攻击的重要手段。

相应的，对于 CSRF 攻击的预防，也有 `SameSite` 属性。

`SameSite` 可以设置为三个值，`Strict`、`Lax`和`None`。

1. 在`Strict`模式下，浏览器完全禁止第三方请求携带cookie。比如请求`keke.com`网站只能在`keke.com`域名当中请求才能携带cookie，在其他网站请求不能
2. 在`Lax`模式，就宽松一点了，但是只能在`get方法提交表单`或者`a标签发送get请求`，的情况下可以携带cookie，其他的情况均不能。
3. 在`None`模式下，也就是默认模式，请求会自动携带上 Cookie

#### cookie的缺点

1. **容量缺陷**。cookie的体积上限只有`4kb`，只有用来存储少量的信息。
2. **性能缺陷**。cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 cookie ，请求都会携带上完整的 cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。但可以通过Domain和Path指定作用域来解决。
3. **安全缺陷**。由于cookie以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截取，然后进行一系列篡改，在cookie的有效期内重新发送给服务器，这是相当危险的。另外，在`HttpOnly`为false的情况下，cookie信息能直接通过js 脚本来获取。

## 如何理解HTTP代理

我们知道在HTTP是基于`请求-响应`模型的协议，一般由客户端发请求，服务器来进行响应。

当然。也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有双重身份。

### 功能

1. **负载均衡**。客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。（常用的见的算法有：随机算法，轮询，一致性hash，LRU等等）
2. **保障安全**。利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对于非法IP限流，这些都是代理服务器的工作
3. **缓存代理**。将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。

### 相关头部字段

#### Via

代理服务器需要标明自己的身份，在HTTP传输中留下自己的痕迹。

通过Via字段来记录。举个例子，现在中间有两台代理服务器，在客户端发送请求会经历这样的过程：

```html
客户端 -> 代理1 -> 代理2 -> 源服务器
```

在源服务器收到请求后，会在`请求头`拿到这个字段：

```html
Via: proxy_server1, proxy_server2
```

而源服务器响应时，最终在客户端会拿到这样的`响应头`:

```html
Via: proxy_server2, proxy_server1
```

可以看到，Via中代理的顺序即为在 HTTP 传输中报文传达的顺序。

#### X-Forwarded-For

字面意思就是`为谁转发`, 它记录的是请求方的IP地址(注意，和`Via`区分开，`X-Forwarded-For`记录的是请求方这一个IP)。

#### X-Real-IP

是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的IP。

相应的，还有`X-Forwarded-Host`和`X-Forwarded-Proto`，分别记录客户端(注意哦，不包括代理)的`域名`和`协议名`。

#### X-Forwarded-For产生的问题

前面可以看到，`X-Forwarded-For`这个字段记录的是请求方的 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从`客户端`到`代理1`，这个字段是客户端的 IP，从`代理1`到`代理2`，这个字段就变为了代理1的 IP。

但是这会产生两个问题:

1. 意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。
2. 在 HTTPS 通信加密的过程中，原始报文是不允许修改的。

由此产生了`代理协议`，一般使用明文版本，只需要在 HTTP 请求行上面加上这样格式的文本即可:

```js
// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口
PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222
GET / HTTP/1.1
...
```

这样就可以解决`X-Forwarded-For`带来的问题。
