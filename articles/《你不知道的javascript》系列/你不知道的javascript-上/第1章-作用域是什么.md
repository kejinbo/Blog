# 作用域是什么

## 编译原理

虽然javascript归类为“动态”或“解释执行”语言，但是事实上他是一门编译语言。但是与传统的编译语言不同，他不是提前编译的、编译结果也不能在分布式系统中进行移植

在传统编译语言中，程序中的一段源码代码在执行之前会经历三个步骤，统称为“编译”。

- 分词/词法分析（Tokenizing/Lexing）  
  这个过程会将由字符串组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。
- 解析/语法分析（parsing）  
  这个过程是将词法单元流（数组）转成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个数被称为“抽象语法树”（abstract syntax tree， AST）。
- 代码生成  
  将AST转换为可执行代码的过程被称为代码生成。这个过程与语言、平台等相关。

比起那些编译过程只有三个步骤的语言的编辑器，javascript引擎要复杂得多，例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化。但简单的说，任何javascript代码片段在执行前都要进行编译（**通常就在执行前**）。

## 理解作用域

在解释作用域之前，我们先定义三个角色，以便后面理解

- 引擎  
  从头到尾负责整个javascript程序的编译以及执行过程
- 编译器  
  引擎的好朋友之一，负责语法分析以及代码生成等事情
- 作用域  
  引擎的另一个好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规定，确定当前执行的代码对这些标识符的访问权限。

定义好角色后，我们来分解一下`var a = 2;`，看看三个角色是如何协同工作的。

编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。

事实上编译器会进行如下操作：

1. 编译器遇到 `var a` ，先询问当前作用域是否有同名的变量，如果有，编译器会忽略该声明；否则编译器会要求作用域子在当前作用域集合中声明新的变量
2. 接下来编译器会为引擎生成运行时所需的代码，当执行到 `a = 2`，引擎会查找当前作用域是否有 a 变量，如果有则进行赋值操作；如果没有，引擎会继续往上一层的作用域查找，知道查找到，如果都没查找到将会抛出错误。

**总结**：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没声明过），然后在运行时引擎在作用域中查找该变量，如果能找到就会对他赋值。

### 编译器有话说

编译器在查找变量 a 的时候判断它是否声明过以及使用变量这个过程中，会对变量 a 进行 `LHS` 和 `RHS`操作。

换句话说，当变量出现在赋值操作的左侧时进行 `LHS` 查询，出现在右侧进行`RHS`查询。`LHS`查询则试图找到变量的容器本身，`RHS`查询与简单地查找某个变量的值别无二致。

概念上可以将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。

## 作用域嵌套

作用域是根据名称查找变量的一套规则。实际情况中，还需要顾忌几个作用域。

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域继续查找，直到找到该变量或抵达最外层的作用域（也就是全局作用域）为止。

遍历嵌套作用域链的规则很简单：引擎从**当前的执行作用域**开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没有找到，查找过程都会停止。
