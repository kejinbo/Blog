# 第4章-强制类型转换

## 值类型转换

将值从一种类型转换为另一种类型通常称为`类型转换`，这是显式的情况；隐式的情况称为`强制类型转换`。

在js中，`强制类型转换`，我们可以使用“隐式强制类型转换”和“显示强制类型转换”来区分。

两者的区别：我们能从代码中看出哪些地方是显示强制类型转换，而隐式强制类型转换则没那么明显，通常是**某些操作产生的副作用**

```js
var a = 42;

var b = a + '';    //隐式强制类型转换
var c = String(a); //显示强制类型转换
```

## 抽象值操作

es6规范定义了一些“抽象操作”（即“仅供内部使用的操作”）和转换规则。现在我们讲讲 `ToString`、`ToNumber`和`ToBoolean`，以及`ToPrimitive`。

### ToString

抽象操作 `ToString`，它负责处理非字符串到字符串的强制类型转换。

基本类型值的字符串化规则为：`null`转换为 `"null"`，`undefined` 转换为 `"undefined"`等。对于普通对象来说，除非自定义，否则 `toString()` （Object.prototype.toString()）返回内部属性[[Class]]的值，然而如果对象有自己的 `toString()` 方法，字符串化时就会调用该方法并使用其返回值。

数组的默认 `toString()` 方法经过了重新定义，将所有单元字符串化以后再用 "," 连接起来。

`toString()` 可以被显式调用，或者在需要字符串化时自动调用。

#### JSON字符串化

工具函数JSON.stringify()在将json对象序列化为字符串的时候也用到了 ToString。

所有安全的JSON值（JSON-safe）都可以使用JSON.stringify() 字符串化。安全的JSON值是指能够呈现为有效JOSON格式的值

不安全的JSON值。undefined、function、symbol和包含循环引用（对象之间互相引用，形成一个无限循环）的对象都不符合JSON结构标准。

`JSON.stringify()`在对象中遇到 undefined，function和 symbol时会自动将其忽略，在数组中则会返回null

```js
JSON.stringify(undefined);        // undefined
JSON.stringify(function(){});     // undefined

JSON.stringify(
  [1, undefined, function(){}, 4] // "[1,null,null,4]"
);

JSON.stringify(
  {a:2, b: function(){}}          // "{"a":2}"
);
```

如果对象中定义了toJSON()方法，JSON字符串化时首先调用该方法，**然后用它的返回值进行序列化。** 注意，toJSON()返回的不是字符串化后的值，而是一个能被字符串化的安全的JSON值。

### ToNumber
