# 第3章-原生函数

常用的原生函数（内建函数）有：

- String()
- Number()
- Boolean()
- Array()
- Object()
- Function()
- RegExp()
- Date()
- Error()
- Symbol()--ES6中新加入

上面的基本数据类型的原生函数可以当构造函数来使用，返回的结果是封装了基本类型值的封装对象。

```js
var a = new String('abc');

typeof a;                           //是"object",不是"string"

a instanceof String;                //true

Object.prototype.toString.call(a);  //"[object String]"
```

## 内部属性`[[Class]]`

所有`typeof`返回为`object`的对象都会包含一个内部属性`[[Class]]`（内部的一个分类，而非传统的面向对象意义上的类）。这个属性无法直接访问，一般通过`Object.prototype.toString()`来查看。对于基本类型值（字符串，数字）使用`Object.prototype.toString()`查看时，会对基本类型值做一层`包装`。

```js
Object.prototype.toString.call([1,2]);     //"[object Array]"
Object.prototype.toString.call(/reg/i);    //"[object RegExp]"
Object.prototype.toString.call(null);      //"[object Null]"
Object.prototype.toString.call(undefined); //"[object Undefined]"
Object.prototype.toString.call("123");     //"[object String]"
Object.prototype.toString.call(123);       //"[object Number]"
```

## 封装对象包装

在js中基本类型值是没有`.length`,`.toString()`等方法和属性的。但是我们依旧可以访问到。这是因为js会自动为这些基本类型值包装一个封装对象

由于浏览器已经为`.length`这些常见的操作做了性能优化，实际上我们不需要对基本类型值包装一个封装对象，即不需要`new String('aaa')`，而是优先考虑使用"aaa"和42这样的基本类型值。

在使用封装对象是需要注意：

```js
var a = new Boolean(false)

if(!a){
  console.log('Foo'); //执行不到
}
```

上面的例子中，为false创建了一个封装对象，但是这个封装对象是真值，所以执行不到判断里面的代码。（并不是使用到false）

如果想执行封装基本类型值，可以使用Object()函数（不带new关键字）：

```js
var a = 'abc';
var b = new String(a);
var c = Object(a);

typeof a;                          //"string"
typeof b;                          //"object"
typeof c;                          //"object"

b instanceof String;               //true
c instanceof String;               //true

Object.prototype.toString.call(b); //"[object String]"
Object.prototype.toString.call(c); //"[object String]"
```

使用`valueOf()`函数可以拿到封装对象中的基本类型值，有时还可以使用隐式拆封：

```js
var a = new String('abc');
var b = new Number(42);

a.valueOf();  //'abc'
b.valueOf();  //42

var c = a + "";
c;            //'abc'
typeof c;     //'string'
```

## 原生函数作为构造函数

关于数组（array）、对象（object）、函数（function）和正则表达式，我们通常喜欢以常量的形式创建它们。因为，使用常量和时候构造函数的效果是一样的（创建的值都是通过封装对象来包装）。而且我们也提倡使用常量来创建。

### Array(..)

在使用构造函数Array()时，可以不带`new`关键字。不带时，它会被自动补上。

```js
var a = Array(1,2,3);
a;  //[1,2,3]
```

有时我们可能会通过创造函数`Array()`，还有使用`delete`操作数组，使其变成一个空单元数组，但空单元数组在不同浏览器上的显示总是存在差异，而且让人误解。虽然通过索引可以获取到对应位置的值`undefined`，但其实该空单元值跟`undefined`还是有所区别的，`map()`在遍历空单元的时候是会报错的，而遍历`undefined`单元（非空单元）时不会报错。

总之，永远不要创建和使用空单元数组。

### Object()、Function()和RegExp()

同样，除非万不得已，否则尽量不要使用Object()、Function()和RegExp()，去new一个对象。

建议常量形式来定义正则表达式，语法简单，并且执行效率高，因为js引擎在代码执行前会对它们进行预编译和缓存。不过，有时还是需要`Regexp()`，动态定义正则表达式的。

```js
var name = 'foo';
var namePattern = new RegExp( "\\b(?:" + name + ")+\\b", "ig");

var matches = someText.match(namePattern)
```

### Date() 和 Error()

相对于其他原生构造函数，`Date()` 和 `Error()`的使用率大得多，因为他们没有对应的常量形式作为它们的替代。

创建日期对象时必须使用 `new Date()`。不使用 `new`关键字，默认得到日期的字符串值。

使用日期对象中的`getTime()`可以获取当前的Unix时间戳（从1970年1月1日开始算，以秒为单位）。ES5开始新增了一个静态函数`Date.now()`。

```js
// Date.now()  polyfill
if(!Date.now){
  Date.now = function(){
    return (new Date()).getTime();
  }
}
```

构造函数 `Error()` （与前面的Array()类似）带不带new关键字都可。通常与 thorw一起使用，便于调试。

### Symbol()

es6中新加入的基本数据类型————符号（Symbol）。符号是具有唯一性的特殊值（并非绝对），用它来命名对象属性不容易导致重名。`Symbol()`不能带new 关键字，否则会报错。

符号可以用作属性名，但无论是在代码还是控制台中都无法查看和访问它的值，只会显示为诸如`Symbol(Symbol.create)`这样的值。

### 原生原型

原生构造函数有自己的 `.prototype` 对象，如 `Array.prototype`、`String.prototype`等。这些对象包含其对应子类型所持有的行为特征。

不过需要注意的是，有些原生原型（native prototype）并非普通对象这么简单：

```js
typeof Function.prototype;     //"function"
Function.prototype();          //空函数

RegExp.prototype.toString();   //"/(?:)/"————空正则表达式
"abc".match(RegExp.prototype); //[""]
```

我们甚至还可以修改他们：

```js
Array.isArray(Array.prototype); //true
Array.prototype.push(1,2,3);    //3
Array.prototype;                //[1,2,3]

//需要将Array.prototype设置为空，否则会导致问题！
Array.prototype.length = 0;
```

对于未赋值的变量来说，原型也是个很好的默认值。

```js
function isThisCool(vals,fn,rx){
  vals = vals || Array.prototype;
  fn = fn || Function.prototype;
  rx = rx || RegExp.prototype;

  return rx.test(
    vals.map(fn).join("")
  );
}
```

但是需要注意的是，上面的例子如果使用默认值，修改的将是原型。这可能会造成意想不到的错误。所以在使用原型作为默认值时，需要特别小心。

## 小结

js为基本数据类型值提供了封装对象，成为原生函数（如String、Number、Boolean等）。它们为基本数据类型值提供了该子类型所持有的方法和属性（如：`String.prototype.trim()`和`Array.prototype.concat()`）。

对于简单标量基本类型值。如`"abc"`，如果要访问它的`length`属性或者`String.prototype`方法，js引擎会自动对该值进行封装（即用相应类型的封装对象来包装它）来实现对这些属性和方法的访问
